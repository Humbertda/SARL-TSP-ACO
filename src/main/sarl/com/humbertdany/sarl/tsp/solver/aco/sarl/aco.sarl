package com.humbertdany.sarl.tsp.solver.aco.sarl

import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import com.humbertdany.sarl.tsp.solver.aco.AntColonyTspSolver
import io.sarl.core.DefaultContextInteractions
import com.humbertdany.sarl.tsp.solver.aco.params.AcoParameters
import io.sarl.core.Schedules
import io.sarl.core.Behaviors
import com.humbertdany.sarl.tsp.solver.generic.ALauncher
import com.humbertdany.sarl.tsp.solver.generic.NewGraphState
import com.humbertdany.sarl.tsp.tspgraph.TspGraph
import com.humbertdany.sarl.tsp.tspgraph.TspVertex
import java.util.List
import java.util.ArrayList
import java.util.HashMap
import io.sarl.lang.core.Address
import io.sarl.util.Scopes 
import com.humbertdany.sarl.tsp.core.graph.Edge
import com.humbertdany.sarl.tsp.tspgraph.VertexInfo
import java.util.Random
import com.humbertdany.sarl.tsp.solver.aco.utils.AcoTspEdgeData
import com.humbertdany.sarl.tsp.solver.generic.StopSolvingEvent
import com.humbertdany.sarl.tsp.solver.generic.NewBestPath

/**
 * Start the solving 
 * Used as first sent and should loop
 */
event NewTick {
	var i : int = 0; 
}

event AntDiedEvent {
	
}

event NewTspProblemParameters {
	var params : AcoParameters
}

event FourmiFinishedWorking {
	var totalCost : double;
	var flow : List<TspVertex>;
}

event InternalBehaviorInitialize {
	
}

event NewTspGraphFourmiliere {
	var graph : TspGraph
}

event FourmiAskDieEvent {
	
}

event FourmiFinishedRaceEvent {
	
}

event AntTickOver {
	var vertex : TspVertex
}

event AntReadyForWork {
	
}
 
event ProcessControllerEvent {
	 
}

/**
 * Handling all the stuff about getting parameters 
 */
abstract behavior AcoControllerBehavior {
	
	/** 
	 * The TspGraph currently solving
	 */
	var graph : TspGraph = null;
	
	var ready : boolean = false;
	
	/** 
	 * Store the parameters available 
	 * for the solver
	 * (Number of ants, etc.)
	 */
	var params : AcoParameters;

	on NewTspProblemParameters { 
		if (occurrence.params != null) {
			params = occurrence.params;
			ready = graph != null && params != null
			defineFourmiliereParams
		}
	}

	on NewGraphState {
		if (occurrence.graph != null) {
			graph = occurrence.graph;
			ready = graph != null && params != null
			defineFourmiliereParams
		}
	}
	
	abstract def defineFourmiliereParams;
	
}

/**
 * The Agent that register this behavior 
 * will watch the graph and check if a solution
 * is available
 */
behavior SolutionObserverBehavior extends AcoControllerBehavior {

	uses DefaultContextInteractions, Logging
	
	var visitedMap : HashMap<Address, List<String>> = new HashMap();
	
	var bestCostSoFar : Double = -1.0; // Impossible cost at the beginning
	var bestWaySoFar : List<TspVertex> = new ArrayList();

	on NewGraphState {
		visitedMap = new HashMap();
		bestCostSoFar = -1.0;
		bestWaySoFar = new ArrayList();
	}
	
	on FourmiFinishedWorking {
		if (bestCostSoFar == -1.0) {
			bestCostSoFar = occurrence.totalCost;
			bestWaySoFar = occurrence.flow
			newBest
		} else if (occurrence.totalCost < bestCostSoFar) {
			bestCostSoFar = occurrence.totalCost;
			bestWaySoFar = occurrence.flow
			newBest
		}
	}
	
	def newBest {
		var strRes : StringBuilder = new StringBuilder;
		for (e : bestWaySoFar){
			strRes.append(e.name).append(" > ")
		}
		var evt = new NewBestPath;
		evt.flow = bestWaySoFar
		emit(evt)
	}

	on AntTickOver {
		var addr = occurrence.source;
		var vertex = occurrence.vertex;
		if (visitedMap.get(addr) == null) {
			visitedMap.put(addr, new ArrayList())
		}
		var visitedList = visitedMap.get(addr)
		if (visitedList != null) {
			if (!visitedList.contains(vertex.name)) {
				visitedList.add(vertex.name)
				if (visitedList.size == graph.verticies.size) {
					emit(new FourmiFinishedRaceEvent, Scopes.addresses(occurrence.source));
				}
			}
		}
	}

	override protected defineFourmiliereParams {
		// Nothing has to be done for the observer, already up to date
	}

}

/**
 * The Agent that register this behavior 
 * will handle the Fourmiliere, and so the solving process
 */
behavior FourmiliereBehavior extends AcoControllerBehavior {

	uses DefaultContextInteractions
	
	var antsCount : int = 0;
	var desiredAntsCount : int = 0;

	/**
	 * Here we are checking the number of ants and if we need to kill some
	 * or to spawn some
	 */
	on ProcessControllerEvent [isFromMe(occurrence) && ready] {
		if (antsCount != desiredAntsCount) {
			// Not enough fourmi, spawning some to get the count
			if (antsCount < desiredAntsCount) {
				for (var i = 0; i < desiredAntsCount - antsCount; i++) {
					spawnAnt
				}
			} else {
				killAllAnts
			}
		}
	}

	def spawnAnt {
		spawn(Fourmi, graph.rootVertex, params)
		antsCount++;
	}

	on AntDiedEvent [!isFromMe(occurrence)] {
		antsCount--;
	}

	on NewGraphState {
		killAllAnts
	}

	def killAllAnts {
		emit(new FourmiAskDieEvent)
	}
	
	on StopSolvingEvent {
		killAllAnts
	}
	
	/** 
	 * Define the optimal desired fourmi count
	 */
	override protected defineFourmiliereParams {
		if (ready) {
			// Check Number of ants
			var mapSize = graph.verticies.size;
			var s = params.antsNumber.toLowerCase;
			if (s.equals("few")) {
				desiredAntsCount = mapSize * 1 // - Ants /Vertex
			} else if (s.equals("alot")) {
				desiredAntsCount = mapSize * 8 // - Ants / Vertex
			} else {
				desiredAntsCount = mapSize * 20 // - Ants / Vertex
			}
		}
	}

}

/**
 * The Agent that register this behavior 
 * will handle the Ants lifecycle (ticks)
 */
behavior TickSyncronizer extends AcoControllerBehavior {
	
	uses DefaultContextInteractions, Schedules, Behaviors, Logging 
	
	var lastTickEmitted : long = System.currentTimeMillis();

	var isProcessing : boolean = false;
	
	/**
	 * Store TRUE if the Ant has done working,
	 * FALSE otherwise
	 */
	var workersMap : HashMap<Address, Boolean> = new HashMap();

	on ProcessControllerEvent [isFromMe(occurrence) && !isProcessing && ready] {
		isProcessing = true;
		var allDone = true;
		for (e : workersMap.values) {
			if (e == false) {
				allDone = false;
			}
		}
		if (allDone) {
			var currentMs = System.currentTimeMillis()
			var timeBetweenLastTick = currentMs - lastTickEmitted;
			for (e : workersMap.entrySet) {
				e.value = false;
			}
			if (timeBetweenLastTick < params.msBetweenTick) {
				in(params.msBetweenTick - timeBetweenLastTick) [
					fireNewTick
				]
			} else {
				fireNewTick
			}
		} 
		isProcessing = false;
	}

	on AntTickOver [!isFromMe(occurrence)] {
		workersMap.replace(occurrence.source, true)
	}

	on AntReadyForWork {
		workersMap.put(occurrence.source, false)
		emit(new NewTick, Scopes.addresses(occurrence.source))
	}

	on AntDiedEvent [!isFromMe(occurrence)] {
		workersMap.remove(occurrence.source)
	}

	def fireNewTick {
		lastTickEmitted = System.currentTimeMillis()
		var evt = new NewTick
		evt.i = 1;
		emit(evt);
	}

	override protected defineFourmiliereParams {
		// Nothing to do with it in this behavior
	}
	
}

/**
 * Agent Fourmi
 * 'Ant' comportement for ACO
 */
agent Fourmi {
	
	uses Logging, Schedules, Lifecycle, DefaultContextInteractions
	
	var currentVertex : TspVertex;
	
	var visitedVertex : List<TspVertex> = new ArrayList();

	var random : Random = new Random();
	
	var totalCost : Double = 0.0;
	
	var isDiying : boolean = false;
	
	/** 
	 * Store the parameters available 
	 * for the solver
	 * (Number of ants, etc.)
	 */
	var params : AcoParameters;
	
	on Initialize {
		setLoggingName("Fourmi") 
		currentVertex = occurrence.parameters.get(0) as TspVertex
		params = occurrence.parameters.get(1) as AcoParameters;
		emit(new AntReadyForWork)
	}

	/**
	 * The Ant does not decide when she run
	 * But she inform the Colony when she is done working
	 */
	on NewTick [!this.isFromMe(occurrence) && !isDiying] {
		
		var destination : Edge<VertexInfo>;
		
		// Get the available Ant moves
		var availableEdgesMoves : List<Edge<VertexInfo>> = new ArrayList(); 
		for (edge : currentVertex.outgoingEdges) { 
			if (!(edge.to.name.equals(currentVertex.name))) {
				availableEdgesMoves.add(edge)
			} 
		}
		
		// Find the best move
		// Calculate all the probabilities
		var allowedYSum : double  = 0d;
		var transitionProbabilities : double[] = newDoubleArrayOfSize(availableEdgesMoves.size);
		var counter : int = 0;
		for (e : availableEdgesMoves) {
			var proba : double = computeNumerator(e);
			transitionProbabilities.set(counter, proba);
			allowedYSum += proba;
			counter++;
		}
		
		// Add the sub
		var counter2 : int = 0;
		var sum : double  = 0d;
		for (e : availableEdgesMoves) {
	        var weighted : double = transitionProbabilities.get(counter2) / allowedYSum;
	        transitionProbabilities.set(counter2, weighted);
	        sum += weighted;
			counter2++;
		}
		
		// Select the move
		var counter3 : int = 0;
		var random : double = random.nextDouble * sum;
		for (e : availableEdgesMoves) {
			random -= transitionProbabilities.get(counter3);
			if (random <= 0 && destination == null) {
				destination = e;
			}
			counter3++;
		}
		 
		if (destination != null) {
			var data : AcoTspEdgeData = destination.data as AcoTspEdgeData;
      		var dampened : Double = 0.001 / totalCost;
			data.adjustWeight(dampened, params.phEvaporation);
			currentVertex = destination.to as TspVertex;
			visitedVertex.add(currentVertex)
			totalCost = totalCost + destination.cost; 
			emit(new AntTickOver => [vertex = currentVertex]);
		} else {
			killMySelf 		// She is buggy
		}
	}
	
	on FourmiFinishedRaceEvent {
		var evt : FourmiFinishedWorking = new FourmiFinishedWorking();
		evt.flow = this.visitedVertex;
		evt.totalCost = totalCost;
		emit(evt); 
	}
	
	on FourmiAskDieEvent [!isDiying] {
		killMySelf
	}
	
	def killMySelf {
		isDiying = true;
		emit(new AntDiedEvent);
		in(3000) [
			killMe
		]
	}

	on NewTspProblemParameters {
		if (occurrence.params != null) {
			params = occurrence.params;
		}
	}
	
	def computeNumerator(e : Edge<VertexInfo>) : Double {
		var to = e.to as TspVertex;
	    var weight : Double = currentVertex.cost(to)
	    if (weight != 0d) {
			return (Math.pow(weight, params.alpha) * Math.pow(e.cost / weight, params.beta));
		}
		return 0d;
	}
	
}

/**
 * Agent used to pipe message with Java
 * Has the Fourmiliere Behavior 
 */
agent Launcher extends ALauncher {
	
	uses DefaultContextInteractions, Behaviors, Logging, Schedules
	
	var fourmiliereBehavior : FourmiliereBehavior;
	var solutionObserverBehavior : SolutionObserverBehavior;
	var ticksSync : TickSyncronizer;
	
	on Initialize {
		solver = occurrence.parameters.get(0) as AntColonyTspSolver;
		
		// Register Both ACO Behavior
		fourmiliereBehavior = new FourmiliereBehavior(this)
		registerBehavior(fourmiliereBehavior);

		solutionObserverBehavior = new SolutionObserverBehavior(this);
		registerBehavior(solutionObserverBehavior);

		ticksSync = new TickSyncronizer(this)
		registerBehavior(ticksSync);
		
		emit(new NewTspProblemParameters => [params = solver.parameters as AcoParameters]);
		wake(new InternalBehaviorInitialize)
		wake(new ProcessControllerEvent)
		setLoggingName("Launcher")
	}

	on ProcessControllerEvent {
		in(200) [ // It loop on himself to handle
			wake(new ProcessControllerEvent);
		]
	}

	on NewTick {
		fireNewState
	}
	
}