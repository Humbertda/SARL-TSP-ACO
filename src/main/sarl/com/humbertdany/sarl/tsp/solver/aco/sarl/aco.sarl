package com.humbertdany.sarl.tsp.solver.aco.sarl

import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import com.humbertdany.sarl.tsp.solver.aco.AntColonyTspSolver
import io.sarl.core.DefaultContextInteractions
import com.humbertdany.sarl.tsp.solver.aco.params.AcoParameters
import io.sarl.core.Schedules
import io.sarl.core.InnerContextAccess
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Behaviors
import com.humbertdany.sarl.tsp.solver.generic.ALauncher
import com.humbertdany.sarl.tsp.solver.generic.NewTick
import com.humbertdany.sarl.tsp.solver.generic.NewGraphState
import com.humbertdany.sarl.tsp.tspgraph.TspGraph
import com.humbertdany.sarl.tsp.solver.generic.StopSolvingEvent
import com.humbertdany.sarl.tsp.tspgraph.TspVertex
import io.sarl.util.Scopes
import java.util.List
import java.util.ArrayList
import com.humbertdany.sarl.tsp.tspgraph.TspEdgeData
import com.humbertdany.sarl.tsp.solver.generic.StartSolvingEvent

// ACO SOLVING //

event NewTspProblemParameters {
	var params : AcoParameters
}

event InternalBehaviorInitialize {
	
}

event NewTspGraphFourmiliere {
	var graph : TspGraph
}

event FourmiAskDieEvent {
	
}

event SendNewCurrentVertex {
	var vertex : TspVertex
}

behavior FourmiliereBehavior {

	uses Logging, DefaultContextInteractions, Schedules, Behaviors
	
	/** 
	 * The TspGraph currently solving
	 */
	var graph : TspGraph;
	
	/** 
	 * Store the parameters available 
	 * for the solver
	 * (Number of ants, etc.)
	 */
	var params : AcoParameters; 
	
	var antsCount : int = 0;
	var desiredAntsCount : int = 0;
	var pheromoneEvaporation : double = 0.0;
	var msBetweenTick : int = 1;
	
	on NewTspProblemParameters {
		params = occurrence.params;
		defineFourmiliereParams
	}

	on StartSolvingEvent {
		wake(new NewTick);
	}

	on NewGraphState { 
		graph = occurrence.graph;
		defineFourmiliereParams
	}
	
	on SendNewCurrentVertex {
		var currentPosition : TspVertex = occurrence.vertex;
		// TODO
	}
	
	on NewTick {
		if (graph != null && params != null) {
			// Control the fourmi count
			if (antsCount != desiredAntsCount) {
			// Not enough fourmi, spawning some to get the count
				if (antsCount < desiredAntsCount) {
					for (var i = 0; i < desiredAntsCount - antsCount; i++) {
						spawn(Fourmi, graph.rootVertex)
						antsCount++;
					}
				} else {
					emit(new FourmiAskDieEvent)
					antsCount = 0
				}
			}

			for (e : graph.edges) {
				var d = e.data as TspEdgeData
				if (d.pheromoneLevel != null) {
					info(d.pheromoneLevel)
				}
		}
		}
		// Infinite Loop on New Tick event
		in(msBetweenTick) [
			emit(new NewTick)
		]
	}
	
	/**
	 * Define the optimal desired fourmi count
	 */
	def defineFourmiliereParams {
		if (graph != null && params != null) {
			
			// Init pheromone for all unitialized edge
			for (e : graph.edges) {
				var tspEdgeData = e.data as TspEdgeData;
				if (tspEdgeData.pheromoneLevel == null) {
					tspEdgeData.pheromoneLevel = params.phInitialLevel
					tspEdgeData.pheromonePersistence = params.phEvaporation
				}
			}
			
			// Check Number of ants
			var mapSize = graph.verticies.size;
			var s = params.antsNumber.toLowerCase;
			if (s.equals("few")) {
				desiredAntsCount = mapSize / 2
			} else if (s.equals("alot")) {
				desiredAntsCount = mapSize*2
			} else {
				desiredAntsCount = mapSize
			}
			
			// Pheromone Evaporation Check
			if (pheromoneEvaporation != params.phEvaporation) {
				pheromoneEvaporation = params.phEvaporation
				for (e : graph.edges) {
					var tspEdgeData = e.data as TspEdgeData;
					tspEdgeData.pheromonePersistence = pheromoneEvaporation;  
				}
			}
			
			// Update MS Ticks
			if (msBetweenTick != params.msBetweenTick) {
				msBetweenTick = params.msBetweenTick
			}
			
		}
	}
	
}

agent Fourmi {
	
	uses Logging, Schedules, Lifecycle, DefaultContextInteractions
	
	var currentVertex : TspVertex;
	
	var visitedVertexName : List<String> = new ArrayList();
	
	on Initialize {
		setLoggingName("Fourmi")
		currentVertex = occurrence.parameters.get(0) as TspVertex
		visitedVertexName.add(currentVertex.name)
	}

	/**
	 * TODO implement Ants
	 */
	on NewTick {
		var dest : TspVertex;
		for (var i = 0; i < currentVertex.outgoingEdgeCount; i++) { 
			var edge = currentVertex.outgoingEdges.get(i)
			var to = edge.to as TspVertex;
			var data = edge.data as TspEdgeData;
			if (!to.name.equals(currentVertex.name)) {
				var value : double = (data.pheromoneLevel - 0.1); //TODO
				data.adjustWeight(value); 
				if (!visitedVertexName.contains(to.name)) {
					dest = to;
				}
			}
		}
		if (dest != null) {
			currentVertex = dest;
			visitedVertexName.add(currentVertex.name)
			emit(new SendNewCurrentVertex => [vertex = currentVertex])
		}
	}

	on StopSolvingEvent {
		killMySelf
	}
	
	on FourmiAskDieEvent {
		killMySelf
	}
	
	def killMySelf {
		in(100) [
			killMe
		]
	}	
	
}


// LAUNCHER //


/**
 * Agent used to pipe message with Java
 * Has the Fourmiliere Behavior 
 */
agent Launcher extends ALauncher {
	
	uses DefaultContextInteractions, Behaviors, Logging
	
	/**
	 * Store the AntColonyTspSolver reference
	 * to call some specific method 
	 * (like sending the actual Graph State)
	 */
	var solver : AntColonyTspSolver;
	
	var fourmiliereBehavior : FourmiliereBehavior;
	
	on Initialize {
		solver = occurrence.parameters.get(0) as AntColonyTspSolver;
		fourmiliereBehavior = new FourmiliereBehavior(this)
		registerBehavior(fourmiliereBehavior);
		emit(new NewTspProblemParameters => [params = solver.parameters]);
		wake(new InternalBehaviorInitialize)
		setLoggingName("Launcher")
	}

	on NewTick {
		fireNewState
	}
	
}