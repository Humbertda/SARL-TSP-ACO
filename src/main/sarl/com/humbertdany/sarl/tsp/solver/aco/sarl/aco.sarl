package com.humbertdany.sarl.tsp.solver.aco.sarl

import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import com.humbertdany.sarl.tsp.solver.aco.AntColonyTspSolver
import io.sarl.core.DefaultContextInteractions
import com.humbertdany.sarl.tsp.solver.aco.params.AcoParameters
import io.sarl.core.Schedules
import com.humbertdany.sarl.tsp.solver.aco.EnvironmentListener
import com.humbertdany.sarl.tsp.tspgraph.TspGraph
import io.sarl.core.InnerContextAccess
import io.sarl.core.ExternalContextAccess
import javafx.application.Platform
import java.util.ArrayList

event NewTick {
	
}

event StopSolvingEvent {
	
}

event NewTspProblemParameters {
	var params : AcoParameters
}

event NewGraphState {
	var graph : TspGraph
}

event StartSolvingEvent {
	var graph : TspGraph
}

agent Launcher {
	
	uses Logging, Lifecycle, DefaultContextInteractions, Schedules, InnerContextAccess, ExternalContextAccess

	/**
	 * Store all the variables
	 * that will require to be triggered
	 * on the new states (the solver, etc.)
	 * ! These should only be Java object
	 * if a SARL require it, use the Events
	 * to benefit of parallelism 
	 */
	var listeners = <EnvironmentListener>newArrayList
	
	/**
	 * Store the AntColonyTspSolver reference
	 * to call some specific method 
	 * (like sending the actual Graph State)
	 */
	var solver : AntColonyTspSolver;
	
	/**
	 * Store the parameters available 
	 * for the solver
	 * (Number of ants, etc.)
	 */
	var params : AcoParameters; 
	
	/**
	 * The TspGraph currently solving
	 */
	var graph : TspGraph;

	on Initialize {
		solver = occurrence.parameters.get(0) as AntColonyTspSolver;
		listeners.add(solver)
		params = solver.parameters
		solver.setEventSpace(defaultSpace);
		solver.sarlReady();
	}
	
	on NewGraphState {
		info("A new graph state has been sent by the Aco Controller");
		graph = occurrence.graph;
	}
	
	on StopSolvingEvent {
		killMe
	}
	
	on StartSolvingEvent {
		this.graph = occurrence.graph 
		emit(new NewTick)
	}
	
	on NewTick {
		info(params)
		
		fireNewState
		// Infinite Loop on New Tick event 
		in(params.msBetweenTick) [
			emit(new NewTick)
		]
	}
	
	on NewTspProblemParameters {
		info("Launcher received new parameters from the event NewTspProblemParameters")
		params = occurrence.params;
	}

	def fireNewState {
		if (graph != null) {
			Platform.runLater(new JfxInfoRunnable(listeners, graph));
		} else {
			info("The graph is currently 'null'")
		}
	}
}

/**
 * Runnable used to inform the main Application
 * (running on JavaFX Thread) 
 * of all the changes we have to 
 */
class JfxInfoRunnable implements Runnable {

	var listeners : ArrayList<EnvironmentListener>
	var graph : TspGraph

	new(listeners : ArrayList<EnvironmentListener>, graph: TspGraph) {
		this.listeners = listeners;
		this.graph = graph;
	}
	
	override run {
		for (listener : this.listeners) {
			listener.newGraphState(graph)
		}
	}

}